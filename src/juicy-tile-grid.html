<!-- Import Polymer -->
<!-- <link rel="import" href="../../polymer/polymer.html"> -->
<!-- Import juicy-tile-list -->
<link rel="import" href="../../juicy-tile-list/src/juicy-tile-list.html">

<!-- Define your custom element -->
<polymer-element name="juicy-tile-grid" extends="juicy-tile-list" attributes="layout">

    <template>
    <style>
        /** our grid stuff */
        :host([layout=grid])::shadow #container:not(.disabled),
        :host(:not([layout]))::shadow #container:not(.disabled){
          display: -ms-grid;
          display: -moz-grid;
          display: grid;

          /*grid-auto-columns: 0;
          grid-auto-rows: 0;
          -moz-grid-auto-columns: 0;
          -moz-grid-auto-rows: 0;*/
        }
        polyfill-next-selector { content: ':host([layout=grid])::shadow  #container:not(.disabled)> *,:host(:not([layout]))::shadow  #container:not(.disabled)> *'; }
        :host([layout=grid])::shadow #container:not(.disabled) ::content>*,
        :host(:not([layout]))::shadow #container:not(.disabled) ::content>*,
        :host([layout=grid])::shadow #container:not(.disabled) >*,
        :host(:not([layout]))::shadow #container:not(.disabled) >*  {
            position: static;
        }
        polyfill-next-selector { content: ':host([layout=grid])::shadow  #container.animate> *,:host(:not([layout]))::shadow  #container.animate> *'; }
        :host([layout=grid])::shadow #container.animate ::content>*,
        :host(:not([layout]))::shadow #container.animate ::content>*,
        :host([layout=grid])::shadow #container.animate >*,
        :host(:not([layout]))::shadow #container.animate >*  {
            -webkit-transition: width 0.5s, height 0.5s, top 0.5s, left 0.5s, -webkit-transform 0.5s;
            transition: width 0.5s ease-out, height 0.5s ease-out, top 0.5s ease-out, left 0.5s ease-out, transform 0.5s ease-out;
        }
    </style>
    <shadow></shadow>
    </template>
    <script>
        Polymer('juicy-tile-grid', {
            layout: "grid",
            layoutChanged: function(oldVal, newVal){
                // afterDomReady: this.refresh();
            },
            renderer: function grid( packedTree, elements, offsetX, offsetY ){
                if(this.layout != "grid"){
                    return this.super( [packedTree, elements, offsetX, offsetY] );
                }
                var cols = []; // just position //{position: px, size: px [, gap: bool]}
                var rows = []; // {position: px, size: px [, gap: bool]}
                var renderedGrid = []; //{index: n, name: groupname, row: r, column: c, background, innerHTML, oversize}

                function drawLine( array, position ){
                    var len = array.length;
                    while(len-- && array[len] > position){  // array[len].position > position){  
                    }
                    if(len>-1 && array[len] == position){ // array[len].position == position){
                        return len;
                    } else {
                        array.splice( len+1, 0, position ); // {position: position});
                        return len+1;
                    }
                    return len;
                }
                function drawLinesFromTree( node, offsetX, offsetY ){
                    var ilen = node.items.length;
                    while(ilen--){
                        var item = node.items[ilen];
                        drawLine(cols, offsetX + item.x);
                        drawLine(cols, offsetX + item.x + item.width);

                        drawLine(rows, offsetY + item.y);
                        drawLine(rows, offsetY + item.y + item.height);

                        if(item.items){
                            drawLinesFromTree( item, offsetX + item.x, offsetY + item.y);
                        }
                    }
                }
                drawLinesFromTree(packedTree, 0,0);

                function renderGrid(node, elements, offsetX, offsetY){
                    var childNodeNo = node.items.length,
                        child,
                        element, elementStyle, left, top, colNo, rowNo;  
                    while(childNodeNo--){
                        child = node.items[childNodeNo]
                        element = elements[ child.name || child.index ];
                        elementStyle = element.style;
                        left = ( child.x || 0 ) + offsetX; 
                        top = ( child.y || 0 ) + offsetY;
                        var oversize = child.oversize || 0;
                        colNo = cols.indexOf( left ); 
                        rowNo = rows.indexOf( top ); 
                        // cols are 1 index based
                        elementStyle["grid-column"] = ( colNo + 1 ) + " / span " + ( cols.indexOf( left + child.width ) - colNo );
                        // rows are 1 index based
                        elementStyle["grid-row"]= ( rowNo + 1 ) + " / span " + ( rows.indexOf( top + child.height ) -rowNo );
                        //IE support
                            elementStyle["-ms-grid-column"] = ( colNo + 1 );
                            elementStyle["-ms-grid-column-span"] = ( cols.indexOf( left + child.width ) - colNo );
                            elementStyle["-ms-grid-row"]= ( rowNo + 1 );
                            elementStyle["-ms-grid-row-span"]= ( rows.indexOf( top + child.height ) -rowNo );


                        elementStyle.width = child.widthAdaptive || child.widthDynamic ? "100%" : child.width + "px";
                        // elementStyle.height = ( child.height /*+ 2 * oversize*/ ) + "px";
                        elementStyle.height = child.heightAdaptive || child.heightDynamic ? "100%" : child.height + "px";
                        if(child.background !== undefined) {
                        elementStyle.backgroundColor = child.background || "transparent";
                        }

                        if(child.items){// virtual container
                            renderGrid( child, elements, left, top);
                        }
                    }
                }

                function lineWidths(array){
                    var alen = array.length,
                        str = "";
                    while(alen-- >1){
                        // str = "minmax( " + (array[alen] - array[alen-1]) + "px , max-content ) " + str;
                        str = (array[alen] - array[alen-1]) + "px " + str;
                    }
                    return str;
                }
                function lineWidths2(array){
                    var alen = array.length,
                        str = "";
                    while(alen-- >1){
                        str = "minmax( " + (array[alen] - array[alen-1]) + "px , max-content ) " + str;
                        // str = (array[alen] - array[alen-1]) + "px " + str;
                    }
                    return str;
                }
                var containerStyle = this.$.container.style;
                // containerStyle.display = "-ms-grid";
                // containerStyle.display = "grid";
                renderGrid( packedTree, elements, 0,0);

                containerStyle["grid-template-columns"] = containerStyle["-ms-grid-columns"] = 
                    lineWidths(cols);
                containerStyle["grid-template-rows"] = containerStyle["-ms-grid-rows"] = 
                    lineWidths2(rows);
                // absolute renderer do it as well
                    containerStyle.height = "auto";


              
            },
            packItems: function packDOM2Grid(){
                this.$.container.classList.add("disabled");
                var packedTree = this.super( arguments );
                this.$.container.classList.remove("disabled");
                return packedTree;
            }
        });
    </script>

</polymer-element>
