<!--
`juicy-tile-grid element` - CSS Grid extension of `juicy-tile-list` - masonry-like Polymer Element for sortable tiles that packs efficiently without changing HTML structure (changes CSS only).

@element juicy-tile-grid
@demo https://Juicy.github.io/juicy-tile-grid/
version: 0.1.2
-->
<!-- Import Polymer -->
<link rel="import" href="../../polymer/polymer.html">
<!-- Import juicy-tile-list -->
<link rel="import" href="../../juicy-tile-list/src/juicy-tile-list.html">

<!-- Define your custom element -->
<polymer-element name="juicy-tile-grid" extends="juicy-tile-list" attributes="layout">

    <template>
    <style>
        /** our grid stuff */
        :host([layout=grid])::shadow #container:not(.disabled),
        :host(:not([layout]))::shadow #container:not(.disabled){
          display: -ms-grid;
          display: -moz-grid;
          display: grid;

          /*grid-auto-columns: 0;
          grid-auto-rows: 0;
          -moz-grid-auto-columns: 0;
          -moz-grid-auto-rows: 0;*/
        }
        :host([layout=grid])::shadow #container:not(.disabled) > .juicy-tile,
        :host(:not([layout]))::shadow #container:not(.disabled) > .juicy-tile,
        :host([layout=grid])::shadow #container:not(.disabled) > .containerBackground,
        :host(:not([layout]))::shadow #container:not(.disabled) > .containerBackground{
            position: static;
        }
        :host([layout=grid])::shadow #container.animate > .juicy-tile,
        :host(:not([layout]))::shadow #container.animate > .juicy-tile,
        :host([layout=grid])::shadow #container.animate >.containerBackground,
        :host(:not([layout]))::shadow #container.animate >.containerBackground  {
            -webkit-transition: width 0.5s, height 0.5s, top 0.5s, left 0.5s, -webkit-transform 0.5s;
            transition: width 0.5s ease-out, height 0.5s ease-out, top 0.5s ease-out, left 0.5s ease-out, transform 0.5s ease-out;
        }
    </style>
    <shadow></shadow>
    </template>
    <script>
        Polymer('juicy-tile-grid', {
            layout: "grid",
            layoutChanged: function(oldVal, newVal){
                // afterDomReady: this.refresh();
            },
            parseDeclaration: function(elementElement) {
              var template = this.fetchTemplate(elementElement);
              // make a shadow root
              var root = this.createShadowRoot();
              // stamp template
              var dom = document.importNode(template.content, true);
              // append to shadow dom
              root.appendChild(dom);
              // perform post-construction initialization tasks on shadow root
              //this.shadowRootReady(root, template);
              // return the created shadow root
              this.shadowRoots[elementElement.name] = root;
            },
            renderer: function grid( packedTree, tiles, offsetX, offsetY ){
                if(this.layout != "grid"){
                    return this.super( [packedTree, tiles, offsetX, offsetY] );
                }
                var columnAxes = []; // just position, as Object Numer, with dynamic property 
                //{position: px, dynamic: boolean}
                var dynamicColPos = {};
                var flexibleColumns = {};
                var rowAxes = [];
                var dynamicRowPos = {};
                var flexibleRows = {};

                /** 
                 * Add new line at given position if there is none.
                 * @param {Array} array of lines
                 * @param {Number} position line position
                 * @returns line number for line at given position
                */
                function drawGridLine( array, position ){
                    var len = array.length, newLine;
                    while(len-- && array[len] > position){
                    // while(len-- && array[len].position > position){  
                    }
                    if(len>-1 && array[len] == position){
                    // if(len>-1 && array[len].position == position){
                        return len;
                    } else { 
                        array.splice( len+1, 0, position ); 
                        // array.splice( len+1, 0, {position: position, dynamic: !!dynamic});
                        return len+1;
                    }
                }
                function drawGridLinesFromTree( node, offsetX, offsetY ){
                    var ilen = node.items.length;
                    while(ilen--){
                        var item = node.items[ilen];
                        if(item.hidden){
                            continue;
                        }

                        drawGridLine(columnAxes, offsetX + item.x);
                        drawGridLine(columnAxes, offsetX + item.x + item.width);
                        // if any tile is dynamic, then line is dynamic
                        dynamicColPos[ offsetX + item.x ] |= item.widthDynamic;
                        flexibleColumns[ offsetX + item.x ] |= item.widthFlexible;

                        drawGridLine(rowAxes, offsetY + item.y);
                        drawGridLine(rowAxes, offsetY + item.y + item.height);
                        // if any tile is dynamic, then line is dynamic
                        dynamicRowPos[ offsetY + item.y ] |= item.heightDynamic;
                        flexibleRows[ offsetY + item.y ] |= item.heightFlexible;

                        if(item.items){
                            drawGridLinesFromTree( item, offsetX + item.x, offsetY + item.y);
                        }
                    }
                    // draw lines for end (right bottom) of our container
                    drawGridLine(columnAxes, offsetX + node.width);
                    drawGridLine(rowAxes, offsetY + node.height);
                }
                drawGridLinesFromTree(packedTree, 0,0);
                var that = this;
                function renderGrid(node, tiles, offsetX, offsetY, hideAll){
                    var childNodeNo = node.items.length,
                        child,
                        element, elementStyle, left, top, colNo, rowNo, hidden;  
                    while(childNodeNo--){
                        child = node.items[childNodeNo]
                        element = tiles[ child.id ];
                        if(!element) {
                            continue; //if element is not found, perhaps DOM was not yet rendered? Skip gracefully
                        }
                        elementStyle = element.style;
                        // hide items marked as hidden ;)
                        hidden = hideAll || child.hidden;
                        if(hidden){
                            elementStyle.display = "none";
                            //continue; // do not process children?
                        } else {
                          // force default - block 
                            elementStyle.display = "";
                            left = ( child.x || 0 ) + offsetX; 
                            top = ( child.y || 0 ) + offsetY;
                            var oversize = child.oversize || 0;
                            colNo = columnAxes.indexOf( left ); 
                            rowNo = rowAxes.indexOf( top ); 
                            // columns are 1 index based
                            elementStyle["grid-column"] = ( colNo + 1 ) + " / span " + ( columnAxes.indexOf( left + child.width ) - colNo );
                            // rows are 1 index based
                            elementStyle["grid-row"]= ( rowNo + 1 ) + " / span " + ( rowAxes.indexOf( top + child.height ) -rowNo );
                            //IE support
                                elementStyle["-ms-grid-column"] = ( colNo + 1 );
                                elementStyle["-ms-grid-column-span"] = ( columnAxes.indexOf( left + child.width ) - colNo );
                                elementStyle["-ms-grid-row"]= ( rowNo + 1 );
                                elementStyle["-ms-grid-row-span"]= ( rowAxes.indexOf( top + child.height ) -rowNo );


                            elementStyle.width = child.widthAdaptive || child.widthDynamic || child.widthFlexible ? "100%" : child.width + "px";
                            // elementStyle.height = ( child.height /*+ 2 * oversize*/ ) + "px";
                            elementStyle.height = child.heightAdaptive || child.heightDynamic || child.heightFlexible ? "100%" : child.height + "px";
                            if (child.background !== undefined) {
                                elementStyle.backgroundColor = child.background || "transparent";
                            } else {
                                elementStyle.backgroundColor = "";
                            }
                            elementStyle.outline = child.outline || "";

                            if (oversize) {
                                elementStyle.padding = oversize + "px";
                                elementStyle.margin = "-" + oversize + "px";
                            } else {
                                elementStyle.padding = "";
                                elementStyle.margin = "";
                            }
                        }

                        if(child.items){// virtual container
                            renderGrid( child, tiles, left, top, hidden);
                        }
                    }
                }

                /**
                 * Calculate line widths ( line `n` position - line `n-1` position), 
                 * take dynamic into account `minmax( _width_ px, max-content )`
                 * @param  {Array<Number>} array  array of lines' positions
                 * @param  {Object<Boolean>} dynamic Map  of dynamic lines positions
                 * @return {String}         `grid template-(rows|columns)` compatible setup.
                 */
                function setTracks(gridLines, dynamic, flexible){
                    var alen = gridLines.length - 1, //last one is the border of our grid
                        str = "";
                    while(alen-- >0){
                        // str = "minmax( " + (gridLines[alen] - gridLines[alen-1]) + "fr , max-content ) " + str;
                        // str = (gridLines[alen] - gridLines[alen-1]) + "fr " + str;
                        if( dynamic[ gridLines[alen] ] ){
                           str = "minmax( " + (gridLines[alen+1] - gridLines[alen]) + "fr , max-content ) " + str; 
                        } else if(flexible[ gridLines[alen] ]){

                           // str = "minmax( min-content, " + (gridLines[alen+1] - gridLines[alen]) + "fr ) " + str; // never less than min-content of elements 
                           str = (gridLines[alen+1] - gridLines[alen]) + "fr " + str; 
                        } else {

                           str = (gridLines[alen+1] - gridLines[alen]) + "px " + str; 
                        }
                    }
                    return str;
                }
                var containerStyle = this.$.container.style;
                // containerStyle.display = "-ms-grid";
                // containerStyle.display = "grid";
                renderGrid( packedTree, tiles, 0,0);

                containerStyle["grid-template-columns"] = containerStyle["-ms-grid-columns"] = 
                    setTracks(columnAxes, dynamicColPos, flexibleColumns);

                containerStyle["grid-template-rows"] = containerStyle["-ms-grid-rows"] = 
                    setTracks(rowAxes, dynamicRowPos, flexibleRows);
                // absolute renderer do it as well
                    containerStyle.height = "auto";


              
            },
            packItems: function packDOM2Grid(){
                this.$.container.classList.add("disabled");
                var packedTree = this.super( arguments );
                this.$.container.classList.remove("disabled");
                return packedTree;
            }
        });
    </script>

</polymer-element>
